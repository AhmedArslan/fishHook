% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fishhook.R
\name{annotate.targets}
\alias{annotate.targets}
\title{title}
\usage{
annotate.targets(targets, covered = NULL, events = NULL, mc.cores = 1,
  na.rm = TRUE, pad = 0, verbose = TRUE, max.slice = 1000,
  ff.chunk = 1e+06, max.chunk = 1e+11, out.path = NULL,
  covariates = list(), maxpatientpergene = Inf, ptidcol = NULL,
  weightEvents = FALSE, ...)
}
\arguments{
\item{targets}{path to bed or rds containing genomic target regions with optional target name}

\item{covered}{optional path to bed or rds containing  granges object containing "covered" genomic regions}

\item{events}{optional path to bed or rds containing ranges corresponding to events (ie mutations etc)}

\item{na.rm}{}

\item{pad}{}

\item{verbose}{boolean verbose flag (default == FALSE)}

\item{max.slice}{integer Max slice of intervals to evaluate with  gr.val}

\item{ff.chunk}{integer Max chunk to evaluate with fftab}

\item{max.chunk}{integer gr.findoverlaps parameter}

\item{out.path}{out.path to save variable to}

\item{covariates}{list}

\item{maxpatientpergene}{Sets the maximum number of events a patient can contribute per target}

\item{ptidcol}{string Column where patient ID is stored
region, that target region will get assigned a score of 0.1 for that event. If false, any overlap will be given a weight of 1.}

\item{...}{paths to sequence covariates whose output names will be their argument names, and each consists of a list with
$track field corresponding to a GRanges, RleList, ffTrack object (or path to rds containing that object), $type which can
have one of three values "numeric", "sequence", "interval".
Numeric tracks must have $score field if they are GRanges), and can have a $na.rm logical field describing how to treat NA values
(set to na.rm argument by default)
Sequence covariates must be ffTrack objects (or paths to ffTrack rds) and require an additional variables $signatures, which
will be used as input to fftab, and can have optional logical argument $grep to specify inexact matches (see fftab)
Interval covariates must be Granges (or paths to GRanges rds) or paths to bed files}

\item{weightEvetns}{If true, will weight events by thier overlap with targets. e.g. if 10% of an event overlaps with a target}

\item{targets}{annotated GRanges of targets with fields $coverage, optional field, $count and additional numeric covariates, or path to .rds file of the same; path to bed or rds containing genomic target regions with optional target name}

\item{by}{character vector with which to split into meta-territories}

\item{fields}{by default all meta data fields of targets EXCEPT reserved field names $coverage, $counts, $query.id}

\item{rolling}{if specified, positive integer specifying how many (genome coordinate) adjacent to aggregate in a rolling fashion; positive integer with which to performa rolling sum / weighted average WITHIN chromosomes of "rolling" ranges" --> return a granges}

\item{disjoint}{only take disjoint bins of input}

\item{na.rm}{only applicable for sample wise aggregation (i.e. if by = NULL)}

\item{FUN}{only applies (for now) if by = NULL, this is a named list of functions, where each item named "nm" corresponds to an optional function of how to alternatively aggregate field "nm" per samples, for alternative aggregation of coverage and count.  This function is applied at every iteration of loading a new sample and adding to the existing set.   It is normally sum [for coverage and count] and coverage weighted mean [for all other covariates].  Alternative coverage / count aggregation functions should have two arguments (val1, val2) and all other alt covariate aggregation functions should have four arguments (val1, cov1, val2, cov2) where val1 is the accumulating vector and val2 is the new vector of values.}

\item{verbose}{boolean verbose flag (default == FALSE)}

\item{targets}{annotated targets with fields $coverage, optional field, $count and additional numeric covariates}

\item{model}{fit existing model --> covariates must be present}

\item{return.model}{}

\item{nb}{negative binomial, if false then use poisson}

\item{verbose}{boolean verbose flag (default == TRUE)}

\item{Covariate}{object of type, GRanges, ffTrack, RleList or character. Note that character objects must be paths to files containing one of the other types as a .rds file}

\item{type}{a string indicating the type of Covariate, valid options are: numeric, sequence, interval. See Annotate Targets for more information on Covariate types}

\item{signature}{In the case where a ffTrack object is of type sequence, a signature field is required, see fftab in ffTrack for more information.}

\item{...}{A series of Covariates, note all objects must be of type Cov}

\item{...}{several Cov objects for packaging.}

\item{...}{A series of Covariates, note all objects must be of type Cov_Arr}

\item{obj}{Cov_Arr This is the Cov_Arr to be subset}

\item{range}{vector This is the range of Covariates to return, like subsetting a vector. e.g. c(1,2,3,4,5)[3:4] == c(3,4)}

\item{targets}{Examples of targets are genes, enhancers, 1kb tiles of the genome that we can then convert into a rolling window. This param must be of class "GRanges".}

\item{events}{Events are the given mutational regions and must be of class "GRanges". Examples of events are mutational data (e.g. C->G) copy number variations and fusion events. Targets are the given regions of the genome to annotate and must be of class "GRanges".}

\item{eligible}{Eligible are the regions of the genome that we feel are fit to score. For example in the case of exome sequencing where not all regions are equally represented, eligible can be a set of regions that meet an arbitrary coverage threshold. Another example of when to use eligibility is in the case of whole genomes, where your targets are 1kb tiles. Regions of the genome you would want to exclude in this case are highly repetative regions such as centromeres, telomeres, and satelite repeates. This param must be of class "GRanges".}

\item{covariates}{Covariates are genomic covariates that you belive will cause your given type of event (mutations, CNVs, fusions) that are not linked to the process you are investigating (e.g. cancer biology). In the case of cancer biology we are looking for regions that are mutated as part of cancer progression, and regions that are more suceptable to random mutagenesis such as late replicating or non-expressed region (transcription coupled repair) are potential false positives. Includinig covariates for these will reduce thier prominence in the final data. This param must be of type "Cov_Arr" which can be created by wrapping Cov objects in c(). e.g. c(Cov1,Cov2,Cov3).}

\item{obj}{FishHook object This is the FishHookObject to be subset}

\item{i}{vector subset targets}

\item{j}{vector subset events}

\item{k}{vector subset covariats}

\item{l}{vector susbet eligible}

\item{targets}{Examples of targets are genes, enhancers, 1kb tiles of the genome that we can then convert into a rolling window. This param must be of class "GRanges".}

\item{events}{Events are the given mutational regions and must be of class "GRanges". Examples of events are mutational data (e.g. C->G) copy number variations and fusion events. Targets are the given regions of the genome to annotate and must be of class "GRanges".}

\item{covered}{This is equivalent to Eligible in the FishHook class. Eligible are the regions of the genome that we feel are fit to score. For example in the case of exome sequencing where not all regions are equally represented, eligible can be a set of regions that meet an arbitrary coverage threshold. Another example of when to use eligibility is in the case of whole genomes, where your targets are 1kb tiles. Regions of the genome you would want to exclude in this case are highly repetative regions such as centromeres, telomeres, and satelite repeates. This param must be of class "GRanges".}

\item{covariates}{Covariates are genomic covariates that you belive will cause your given type of event (mutations, CNVs, fusions) that are not linked to the process you are investigating (e.g. cancer biology). In the case of cancer biology we are looking for regions that are mutated as part of cancer progression, and regions that are more suceptable to random mutagenesis such as late replicating or non-expressed region (transcription coupled repair) are potential false positives. Includinig covariates for these will reduce thier prominence in the final data. This param must be of type "Cov_Arr" which can be created by wrapping Cov objects in c(). e.g. c(Cov1,Cov2,Cov3).}

\item{obj}{This is the Annotated object to be subset}

\item{range}{This is the range of targets to return, like subsetting a vector. e.g. c(1,2,3,4,5)[3:4] == c(3,4)}

\item{annotated}{The annotated targets as an output from Annotated$scoreTargets() or the standard score.targets().}

\item{obs}{vector of pvalues to plot, names of obs can be intepreted as labels}

\item{highlight}{optional arg specifying indices of data points to highlight (ie color red)}

\item{samp}{integer, optional specifying how many samples to draw from input data (default NULL)}

\item{lwd}{integer, optional, specifying thickness of line fit to data}

\item{pch}{integer dot type for scatter plot}

\item{cex}{integer dot size for scatter plot}

\item{conf.lines}{logical, optional, whether to draw 95 percent confidence interval lines around x-y line}

\item{max}{numeric, optional, threshold to max the input p values}

\item{label}{character vector, optional specifying which data points to label (obs vector has to be named, for this to work)}

\item{plotly}{toggles between creating a pdf (FALSE) or an interactive html widget (TRUE)}

\item{annotations}{named list of vectors containing information to present as hover text (html widget), must be in same order as obs input}

\item{gradient}{named list that contains one vector that color codes points based on value, must bein same order as obs input}

\item{titleText}{title for plotly (html) graph only}
}
\value{
GRanges of input targets annotated with covariate statistics (+/- constrained to the subranges in optional argument covered)

GRangesList of input targets annotated with new aggregate covariate statistics OR GRanges if rolling is specified

GRanges of scored results

Cov object that can be passed to FishHook object constructor

Cov_Arr object that can be passed directly into the FishHook object constructor

Cov_Arr object that can be passed directly to the FishHook object constructor

Cov_Arr object that can be passed directly into the FishHook object constructor

A new Cov_Arr object that contains only the Covs within the given range

FishHook object that can be annotated.

A new FishHook object that contains only the Covs within the given range

Annotate Obeject that can be scored & manipulated and aggregated.

Annotated object that can manipulated and scored, but cannot be aggregated again.

Score object that can be plotted/analyzed
}
\description{
Takes input of GRanges targets, an optional set of "covered" intervals, and an indefinite list of covariates which can be R objects
(GRanges, ffTrack, Rle) or file paths to .rds, .bw, .bed files, and an annotated target intervals GRanges with covariates computed
for each interval.   These target intervals can be further annotated with mutation counts and plugged into a generalized linear regression
(or other) model downstream.

There are three types of covariates: numeric, sequence, interval.  The covariates are computed as follows:
numeric covariates: the mean value
sequence covarites: fraction of bases satisfying $signature
interval covariates: fraction of bases overlapping feature

Gathers annotated targets across a vector "by" into meta-intervals returned as a GRangesList, and returns the
aggregated statistics for these meta intervals by summing coverage and counts, and performing a weighted average of all other meta data fields
(except query.id)

If rolling = TRUE, will return a rolling collapse of the sorted input where "rolling" specifies the number of adjacent intervals that are aggregated in a rolling manner.
(only makes sense for tiled target sets)

If by = NULL and targets is a vector of path names, then aggregation will be done "sample wise" on the files, ie each .rds input will be assumed to comprise the same 
intervals in teh same order and aggregation will be computed coverage-weighted mean of covariates, a sum of coverage and counts, and (if present) a Fisher combined
of $p values.  Covariates are inferred from the first file in the list.

Scores targets based on covariates using gamma-poisson model with coverage as constant

Override the c operator for covariates so that when you type: c(Cov1,Cov2,Cov3) it returns a Cov_Arr object that support vector like operation.

Override the c operator for covariates so that when you type: c(Cov1,Cov2,Cov3) it returns a Cov_Arr object that support vector like operation.

Overrides the subset operator x[] for use with Cov_Arr to allow for vector like subsetting
}
\author{
Marcin Imielinski

Marcin Imielinski

Marcin Imielinski

Zoran Z. Gajic

Zoran Z. Gajic

Zoran Z. Gajic

Zoran Z. Gajic

Zoran Z. Gajic

Zoran Z. Gajic

Zoran Z. Gajic

Zoran Z. Gajic

Zoran Z. Gajic

Zoran Z. Gajic

Marcin Imielinski, Eran Hodis, Zoran Z. Gajic
}
